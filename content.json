{"meta":{"title":"luffyjet の手帳","subtitle":null,"description":"爱ACGN的绅士","author":"luffyjet","url":"http://www.luffyjet.com/techblog"},"pages":[{"title":"about","date":"2015-04-07T03:15:44.000Z","updated":"2015-04-07T03:18:32.000Z","comments":true,"path":"about/index.html","permalink":"http://www.luffyjet.com/techblog/about/index.html","excerpt":"","text":"暂无"},{"title":"categories","date":"2015-04-07T03:17:01.000Z","updated":"2015-04-07T03:21:23.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.luffyjet.com/techblog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2015-04-07T03:20:28.000Z","updated":"2015-04-07T03:20:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.luffyjet.com/techblog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开源热补丁和插件化项目整理","slug":"hotfix-framework-article","date":"2018-06-08T14:30:12.000Z","updated":"2018-12-04T09:01:12.593Z","comments":true,"path":"2018/06/08/hotfix-framework-article/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2018/06/08/hotfix-framework-article/","excerpt":"开源热补丁框架 支付宝 AndFix QZone方案 (原理 , dex分包方案) HotFix Nuwa DroidFix 微信 Tinker 美团 Robust 其它 RocooFix AnoleFix Phantom 零Hook稳定占坑 兼容Android 9.0（2018.10月更新） 热补丁整合框架 tinker-manager Tinker_imitator Android 傻瓜式分包插件","text":"开源热补丁框架 支付宝 AndFix QZone方案 (原理 , dex分包方案) HotFix Nuwa DroidFix 微信 Tinker 美团 Robust 其它 RocooFix AnoleFix Phantom 零Hook稳定占坑 兼容Android 9.0（2018.10月更新） 热补丁整合框架 tinker-manager Tinker_imitator Android 傻瓜式分包插件 热补丁相关文章 Instant Run英文原文 (https://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f#.c088qhdxu) Instant Run工作原理及用法中文翻译稿 (http://www.jianshu.com/p/2e23ba9ff14b) Buck exopackage 介绍 (https://buckbuild.com/article/exopackage.html) 各大热补丁方案分析和比较 (http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/) 微信Android热补丁实践演进之路 Android 热补丁动态修复框架小结 QFix探索之路—手Q热补丁轻量级方案 微信热补丁 Tinker 的实践演进之路 Android热补丁技术，ClassLoader、dexposed、Andfix、smart app updates补丁技术收集整理 关于Android热修复的几种解决方案 Android热修复技术原理详解 Android P限制 GMTC分享——当插件化遇到 Android P 突破Android P非公开API限制 破解Android P对非SDK接口限制 Android P非公开sdk适配指南 ANDROID 动态加载系列 插件化框架 DynamicLoadApk Qihoo360/DroidPlugin houkx/android-pluginmgr mmin18/AndroidDynamicLoader wequick/Small 换肤 不算插件 limpoxe/Android-Plugin-Framework iReaderAndroid/ZeusPlugin rickdynasty/TwsPluginFramework didi/VirtualAPK 插件化文章 Android博客周刊专题之＃插件化开发＃ Android 插件化 动态升级 liaohuqiu/android-dynamic-load-awesome kaedea/android-dynamical-loading Android热更新方案Robust Android 热补丁技术——资源的热修复 Android 插件技术实战总结 Android插件化原理解析","categories":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}],"tags":[{"name":"hotfix","slug":"hotfix","permalink":"http://www.luffyjet.com/techblog/tags/hotfix/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}]},{"title":"人脸识别调研和部分应用场景","slug":"about-face-detection","date":"2018-04-01T04:30:12.000Z","updated":"2018-12-04T07:49:39.053Z","comments":true,"path":"2018/04/01/about-face-detection/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2018/04/01/about-face-detection/","excerpt":"人脸识别基本流程 人脸识别最难的部分是有充分适应各大光线环境的人脸预处理算法，需要在各种复杂的光线环境中提取到人脸信息，特别是移动互联网时代，摄像头拍照的地方可以在斑驳的树影下，也可以在昏暗的街灯下，以及深夜出租车内，这对算法的鲁棒性考验极大。同时还要考虑照片和视频欺诈，二次成像的光线污染等问题。","text":"人脸识别基本流程 人脸识别最难的部分是有充分适应各大光线环境的人脸预处理算法，需要在各种复杂的光线环境中提取到人脸信息，特别是移动互联网时代，摄像头拍照的地方可以在斑驳的树影下，也可以在昏暗的街灯下，以及深夜出租车内，这对算法的鲁棒性考验极大。同时还要考虑照片和视频欺诈，二次成像的光线污染等问题。人脸识别应用分类派系： 对应解决方案： 相关企业人脸识别公司有很多，大致分为这几类： 一类是，专注算法这块，主要提供的是API，SDK。有的是自己做成了系统，软件。 一类是，专注系统、软件这块，有针对不同行业的解决方案，不过不一定掌握了核心算法。 一类是，人脸识别模块及硬件这块，比如人脸识别考勤机，人脸识别取款机。 国内主要的相关公司： 北京：FACE++，商汤科技，北京可信网络有限公司，脸指，麒麟永盛，百度 四川：凌感科技，四川蓉达，云从科技 广东：颜鉴科技（ColorReco），洪森科技 杭州：杭州微禾 厦门：厦门瑞为 上海：晶软，看看智能，腾讯优图， 部分链接： https://www.faceplusplus.com.cn/ https://cloud.sensetime.com/ https://www.linkface.cn/ http://www.facecore.cn/ http://colorreco.com/ http://www.faceall.cn/ http://www.facefinger.cn/ 国外相关公司 美国Identix公司 美国Bioscrypt公司 德国Cognitec Systems公司 西班牙Herta Security公司 日本NEC公司 日本Softwise公司 以上都是老牌人脸识别公司，美国Identix公司做的是多模认证（指纹、虹膜），而Bioscrypt公司早期起于指纹识别考勤，在政府市场的份额都不小，德国的Cognitec公司主要做政府项目的人脸识别系统，而NEC公司主要做机器人视觉识别系统，西班牙Herta公司是一家学术很浓厚的公司。此外的还有一些以色列公司技术也很不错。这些公司最强的一点是，几乎做的都是政府的安全项目，特别是CIA用的最多，此外还有Facebook等公司也在进入这个领域，互联网公司的加入主要是进行人群的分类和应用的优化（针对性的市场推广），项目都是作为公司原本业务的一种补充，这类几乎不用担心客户问题，因为这些公司本身就有很大的需求。随着人工智能的崛起，人脸识别未来会作为一个强大的功能补充，类似语音一样，成为机器人的标配。 关于算法核心研发情况的争论： 基本上国内每家公司都会说自己的算法牛，实际上有几家有人脸核心算法呢？国内在完全从事算法研究的总工程师人数到目前（2016年）总计不到100人，不过也没有现在问题也不大，中科院计算所山世光教授已经开源了算法模块，没有基础的公司不用太辛苦从零开始在OPENCV基础上做算法升级，相信很快google微软还会有新的算法发布。现在算法基本都是98%以上，这点差距已经不重要，算法核不核心也没有太大问题。大家不用太过于焦虑，产品到应用阶段，单单靠算法可不够，还要考虑实际的使用。 目前人脸识别的常见问题1：1比对源采集的难度： 1vs1，主要用于快速的人脸识别比对，作为身份确认的一种新方式，比如考生身份确认、公司考勤确认、各种证件照和本人确认，由于这些照片源不一定有权威统一的接口调用，所以一直没有用起来。目前市面上做的都是用户自传照片，比如支付宝的人脸比对，用户自传的照片最大的问题是照片质量的合格率太低，拍照的光线、角度等因素会导致采集源的质量下降，不利于后期的大批量人脸特征码管理。 N:N模糊匹配查询：1vsN，这个主要用于排查犯罪嫌疑人、失踪人口的全库搜寻、一人多证的重复排查，以此相似度列出相应的结果，可以大大提高排查效率。类似的也可以用到走失儿童的项目中去 N vs N 该算法实际上是基于视频流的帧处理所用，对服务器的计算环境要求严苛，目前的算法系统所支撑的输出率非常有限，需要等待下一代GPU算法，特别是基于CUDA架构的。该应用主要在一些高级赛事会议场合，以及安保公司的人脸警报系统。 人脸识别的算法能力：拒识率、误识率、通过率，准确率 人脸识别的技术发展方向： 结合三维信息： 二维和三维信息融合使特征更加鲁棒 多特征融合： 单一特征难以应对复杂的光照和姿态变化 大规模人脸比对： 面向海量数据的人脸比对与搜索 深度学习： 在大数据条件下充分发挥深度神经网络强大的学习能力 可供选择的国产供应商国内的企业从估值、客户、产品都是 Face++ 远远胜出，综合能力非常突出。阿里巴巴采用了Face++的人脸识别技术，融资数量Face++最多。另外还有百度和腾讯优图也开放了人脸识别API。百度和腾讯看重的是他们的数据量和雄厚的资金，算法水平也有。 所以综合来看有四家候选，4家全部提供了HTTP API的形式的服务： face++: https://megvii.com/ 商汤科技: https://cloud.sensetime.com/(https://www.linkface.cn/) 百度: http://ai.baidu.com/docs#/Face-API/top 腾讯优图: http://open.youtu.qq.com/ 结合应用场景选择： 用于登录CC+,由于CC+暂时并没有涉及资金安全方面的问题，可以选用免费的服务，比如百度和腾讯。 刷脸验人，比如考勤，安全门禁，这些安全要求较高，需要防止各种作弊，我们可以采用face++旗下的FaceID产品，它是付费服务。 以上几家除了商汤科技都有，开放平台和开放的API提供使用。都具备了人脸识别的各种基本能力。但是都没有免费提供活体检测等高端功能。FaceID，商汤，腾讯都可以通过商务合作购买高级能力。 按行业按业务分类，face++都有成功的案例。另外还有智能地产解决方案，非常契合智慧园区。我们能想到的需求，这一家基本能满足。 智慧园区相关应用智慧园区和人脸识别的结合场景，有很多，比如：出入口人脸门禁，VIP迎宾，远程访客邀约，员工刷脸考勤，会议室管理，地库人脸门禁，访客人证登记，关键区域门禁管理，证件识别，人证比对等等。下面举一些具体的例子。 1.企服大堂，人力资源广场大厅，smart展厅的出入人员管理这些场所人员混杂，通过摄像头采集并分析人脸，可以区分重要领导，进行人脸识别迎宾。记录可疑人员，然后做出提示。摄像头采集的图像通过第三方的人脸识别API进行人脸比对。腾讯和百度都有免费的服务。 2.企服大堂，人力资源广场大厅等服务区的刷脸登记验证读取来访者身份证信息，然后与摄像头抓取的人脸直接对比，验证身份。硬件方面一个平板电脑和身份证读卡器即可实现，这两个设备一般都已经有了。或者你没带身份证，则通过采集的人脸和公安部身份证网上副本进行对比，来验证身份(相关文章)。 3.停车场的安防通过摄像头读取停车场出入人员的人脸信息，结合市局人像数据支撑，进行人脸比对，并对视频流中同一人员行动轨迹进行追踪与分析。防范可疑人员。face++已经有解决方案。 4.办公室门禁保证办公室人员的安全，管理访客，外来人员，周边服务人员。在入口安装高清摄像头，记录人脸，并和我方图片库，进行比对，区分来人。可以采用免费的第三方人脸识别服务。摄像头可以选用海康。 5.办公室考勤办公室出入口安装高清摄像头，只需抬头眨眨眼，实现上下班自动考勤。为了防止作弊，需要引入活体检测。旷视，商汤，腾讯均有活体检测服务，旷视的产品较为成熟。 6.驾驶舱登录驾驶舱登录，目前其实就是CC+的登录。可以通过手机进行人脸识别，完成登录。处于演示阶段的话，可以暂时不用考虑过多安全问题，那么我们可以直接采用免费的人脸识别服务。如果对安全要求高，那么我们需要引入活体检测，防止黑客攻击。 7.作为CC+的一种新的登录方式第一次安装登录CC+需要使用密码登录，设置了刷脸登录之后，退出登录之后就可以使用刷脸进行登录。需要引入活体检测来增强安全性，防止人脸攻击，因此没有免费的方案。 8.社交方面的应用CC+的社交部分，比如发图片的时候可以加入人脸识别，对图片上的人脸进行特殊处理。这部分目前主要也是收费的产品。比如face++。免费的服务目前好像还没有。 9.上下班班车刷脸上车云谷的上下班班车，可以引入人脸识别，用来进行扣费和人员验证。增强了安全性和便捷性。这方面的解决方案可以和faceid进行商讨。他们目前在神州租车和滴滴出行都有类型的应用。 总结，对安全性有要求的场景，都需要活体检测的引入，这块目前都是收费服务。都需要进行商务合作。 相关文章 支付宝人脸识别安全吗？ https://www.zhihu.com/question/57158124","categories":[{"name":"face detection","slug":"face-detection","permalink":"http://www.luffyjet.com/techblog/categories/face-detection/"}],"tags":[{"name":"face detection","slug":"face-detection","permalink":"http://www.luffyjet.com/techblog/tags/face-detection/"}],"keywords":[{"name":"face detection","slug":"face-detection","permalink":"http://www.luffyjet.com/techblog/categories/face-detection/"}]},{"title":"Android面试相关整理","slug":"android-interview","date":"2018-03-15T15:28:55.000Z","updated":"2018-12-04T14:35:24.492Z","comments":true,"path":"2018/03/15/android-interview/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2018/03/15/android-interview/","excerpt":"基础知识 Android 开发工程师面试指南 Java / Android 笔试、面试 知识整理 国内一线互联网公司内部面试题库 InterviewMap 面试图谱 Java Core Sprout 设计模式(菜鸟学院) LeetCode算法题 史上最全 Android 面试资料集合 2018 Android面试心得 Android&amp;Java面试题大全","text":"基础知识 Android 开发工程师面试指南 Java / Android 笔试、面试 知识整理 国内一线互联网公司内部面试题库 InterviewMap 面试图谱 Java Core Sprout 设计模式(菜鸟学院) LeetCode算法题 史上最全 Android 面试资料集合 2018 Android面试心得 Android&amp;Java面试题大全 简历 Android程序员简历模板 这样投简历才有效 架构 ANDROID项目重构之路:架构篇 Android应用架构 (Android Dev Summit 2015) 从零开始的Android新项目 模块化通用框架 插件化详见 热补丁与插件化项目整理 热补丁详见 热补丁与插件化项目整理 其他 TLS详解 深入浅出Dagger2 : 从入门到爱不释手 RxJava 常用的几种方法 Android换肤技术总结 RxBus在rxjava2.0 的使用 Android instrumentation原理 String、StringBuffer、StringBuilder区别 Dagger2入门 关于RxJava背压 Android RxJava实际应用案例 App开发架构指南 在项目中添加添加Architecture Components Android 进阶7：进程通信之 AIDL 的使用 Git原理详解及实用指南 RxJava 沉思录 http://www.androidblog.cn/ Lifecycle+Retrofit+Room完美结合 领略架构之美","categories":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"http://www.luffyjet.com/techblog/tags/Interview/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}]},{"title":"了解一下窄带网联网NB-IoT","slug":"NB-IOT","date":"2018-03-08T04:30:12.000Z","updated":"2018-12-04T07:50:12.656Z","comments":true,"path":"2018/03/08/NB-IOT/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2018/03/08/NB-IOT/","excerpt":"什么是窄带物联网（NB-IoT）？基于蜂窝的窄带物联网（Narrow Band Internet of Things, NB-IoT）俨然已成为万物互联网络的一个重要分支，作为 IoT 领一个新兴的技术，NB-IoT 构建于蜂窝网络，只消耗大约 180KHz 的带宽，可直接部署于 GSM 网络、UMTS 网络或 LTE 网络，以降低部署成本、实现平滑升级。 NB-IoT 支持低功耗设备在广域网的蜂窝数据连接，也被叫作低功耗广域网(LPWA)，支持待机时间长、对网络连接要求较高设备的高效连接。据说 NB-IoT 设备电池寿命可以提高至至少 10 年，同时还能提供非常全面的室内蜂窝数据连接覆盖。","text":"什么是窄带物联网（NB-IoT）？基于蜂窝的窄带物联网（Narrow Band Internet of Things, NB-IoT）俨然已成为万物互联网络的一个重要分支，作为 IoT 领一个新兴的技术，NB-IoT 构建于蜂窝网络，只消耗大约 180KHz 的带宽，可直接部署于 GSM 网络、UMTS 网络或 LTE 网络，以降低部署成本、实现平滑升级。 NB-IoT 支持低功耗设备在广域网的蜂窝数据连接，也被叫作低功耗广域网(LPWA)，支持待机时间长、对网络连接要求较高设备的高效连接。据说 NB-IoT 设备电池寿命可以提高至至少 10 年，同时还能提供非常全面的室内蜂窝数据连接覆盖。 NB-IoT 的前景与优势移动通信正在从人和人的连接，向人与物以及物与物的连接迈进，万物互联是必然趋势。然而当前的 4G 网络在物与物连接上能力不足。事实上，相比蓝牙、ZigBee 等短距离通信技术，移动蜂窝网络具备广覆盖、可移动以及大连接数等特性，能够带来更加丰富的应用场景，理应成为物联网的主要连接技术。作为 LTE 的演进型技术，4.5G 除了具有高达 1Gbps 的峰值速率，还意味着基于蜂窝物联网的更多连接数，支持海量 M2M 连接以及更低时延，将助推高清视频、VoLTE 以及物联网等应用快速普及。蜂窝物联网正在开启一个前所未有的广阔市场。 对于电信运营商而言，车联网、智慧医疗、智能家居等物联网应用将产生海量连接，远远超过人与人之间的通信需求。 NB-IoT 具备四大特点：一是广覆盖，将提供改进的室内覆盖，在同样的频段下，NB-IoT 比现有的网络增益 20dB，覆盖面积扩大 100 倍；二是具备支撑海量连接的能力，NB-IoT 一个扇区能够支持 10 万个连接，支持低延时敏感度、超低的设备成本、低设备功耗和优化的网络架构；三是更低功耗，NB-IoT 终端模块的待机时间可长达 10 年；四是更低的模块成本，企业预期的单个接连模块不超过 5 美元。 NB-IoT 聚焦于低功耗广覆盖（LPWA）物联网（IoT）市场，是一种可在全球范围内广泛应用的新兴技术。其具有覆盖广、连接多、速率低、成本低、功耗低、架构优等特点。NB-IoT 使用 License 频段，可采取带内、保护带或独立载波三种部署方式，与现有网络共存。 因为 NB-IoT 自身具备的低功耗、广覆盖、低成本、大容量等优势，使其可以广泛应用于多种垂直行业，如远程抄表、资产跟踪、智能停车、智慧农业等。3GPP 标准的首个版本预计在今年 6 月发布，到时候将有一批测试网络和小规模商用网络出现。 NB-IoT 的需求与发展随着智能城市、大数据时代的来临，无线通信将实现万物连接。很多企业预计未来全球物联网连接数将是千亿级的时代。目前已经出现了大量物与物的联接， 然而这些联接大多通过蓝牙、Wi-Fi 等短距通信技术承载，但非运营商移动网络。为了满足不同物联网业务需求，根据物联网业务特征和移动通信网络特点，3GPP 根据窄带业务应用场景开展了增强移动通信网络功能的技术研究以适应蓬勃发展的物联网业务需求。 我们正进入万物互联(IoT)的时代，这对于整个移动通信产业来说是一个巨大的机会。无论是运营商大咖，还是设备商巨头，都在展示各自的物联网解决方案和在不同垂直行业的应用。 当然，实现这一切的基础，是要有无处不在的网络联接。运营商的网络是全球覆盖最为广泛的网络，因此在接入能力上有独特的优势。然而，一个不容忽视的现实情况是，真正承载到移动网络上的物与物联接只占到联接总数的 10%，大部分的物与物联接通过蓝牙、Wi-Fi 等技术来承载。 为此，产业链从几年前就开始研究利用窄带 LTE 技术来承载 IoT 联接。历经几次更名和技术演进，2015 年 9 月，3GPP 正式将这一技术命名为 NB-IoT。MWC2016 上，NB-IoT 首次亮相，受到瞩目，运营商和设备商纷纷为其站台和背书。 从技术层面上来讲，NB-IoT 有 4 大技术优势。首先是覆盖广，相比传统 GSM，一个基站可以提供 10 倍的面积覆盖;其次是海量连接，200KHz 的带宽可以提供 10 万个联接;第三是低功耗，使用 AA 电池便可以工作十年，无需充电；第四是低成本，模组成本小于 5 美金。 据了解，NB-IoT 可以广泛应用于多种垂直行业，如远程抄表、资产跟踪、智能停车、智慧农业等。随着 3GPP 标准的首个版本在 6 月份发布，将有一批测试网络和小规模商用网络出现。NB-IoT 将在多个低功耗广域网技术中脱颖而出。 此外，越来越多的行业已经在使用物联网技术提高效率，提升客户满意度并降低运营成本。例如，汽车零部件、家用电器及安全系统制造商博世已经将很多产品线连接起来，并从移动互联技术，尤其是车联网领域的崛起中直接获益。 为了迎接物联网领域的巨大机遇，整个产业不仅需要推动技术创新，还需要推动商业模式创新和跨行业协作。由于用例、应用和商业模式纷繁多样，物联网市场将比移动市场更加碎片化。 NB-IoT标准的应用NB-IoT标准具备四大特点：一是广覆盖，将提供改进的室内覆盖，在同样的频段下，NB-IoT比现有的网络增益20dB，覆盖面积扩大了100倍；二是具备支撑海量连接的能力，NB-IoT一个扇区能够支持10万个连接；三是更低功耗，NB-IoT终端模块的待机时间可长达10年；四是更低的模块成本，企业预期的单个接连模块不超过5美元。 考虑NB-IoT的特性，此标准可可满足对低功耗/长待机、深覆盖、大容量有所要求的低速率业务；同时由于对于移动性支持较差，更适合静态业务场景或非连续移动、实时传输数据的业务场景，并且业务对时延低敏感。可考虑的业务类型如下： 1) 自主异常报告业务类型。如烟雾报警探测器、智能电表停电的通知等，上行数据极小数据量需求（十字节量级），周期多以年、月为单位。 2) 自主周期报告业务类型。如智能公用事业（煤气/水/电）测量报告、智能农业、智能环境等，上行较小数据量需求（百字节量级），周期多以天、小时为单位。 3) 网络指令业务类型。如开启/关闭、设备触发发送上行报告、请求抄表，下行极小数据量需求（十字节量级），周期多以天、小时为单位。 4) 软件更新业务类型。如软件补丁/更新，上行下行较大数据量需求（千字节量级），周期多以天、小时为单位。 迄今为止，华为已联合全球多家运营商在中国、德国、西班牙、阿联酋等国共同完成了基于NB-IoT技术的智能水表、智能停车、智能垃圾箱业务的功能验证。其中沃达丰和华为于2015年底在西班牙完成了NB-IoT预标准的第一个试商用测试，成功地将NB-IoT技术整合到沃达丰现有移动网络中，发送NB-IoT消息给水表中的物联网模块，水表的放置环境通常在壁橱等隐蔽环境，且水表无法外接电源，NB-IoT可有效解决覆盖及功耗等问题。 2016年世界移动大会上，英特尔与爱立信联合中移动推了NB-IoT智能家庭环境监测系统。它采用了英特尔最新的NB-IoT芯片（XMM7115）。并且可以实时监测到环境的PM值、温度、湿度、光感亮度等。中兴通讯推出了基于NB-IoT技术的智能市政下水道管理系统，各种信息直接传到中兴手机上。 另外，华为和上海联通也提出了基于NB-IoT技术的智能停车解决方案，通过现场演示，展示了基于NB-IoT这一新兴物联网接入技术的商业应用探索已经启动。此前，上海联通与华为合作建设了全球首个基于 4.5G NB-IoT的大规模连续覆盖区域—-上海国际旅游度假区，并率先在P1停车场部署了300多个基于NB-IoT技术的智能车检器，并提供从终端，基站，服务器，手机应用的端到端智能停车方案。用户可以在手机上实现车位查询、预定、导航、移动支付以及停车场管理等功能，解决了游客找车位难的问题，并一定程度缓解了交通拥堵。 面临的挑战与机遇NB-IoT相较于传统物联网技术有着自身的优势。不过，其仍旧有着自身的局限性。根据TR45.820中典型业务模型下的仿真测试数据，单小区可支持10万个NB-IoT终端接入。但是，这种纯中心的网络管理方式，可能会造成过长的轮询周期，像物联网这种高密度网络不一定适合采用中心管理模式，轮询一遍的时间成本可能令系统承受。物联网采用分层模式可能会效率更高。 无线抄表始终都会面临一个问题，就是信号覆盖问题。面对无信号覆盖或者信号受干扰的情况，无线抄表即使优点再多也无用武之地。而且，我国国网已经基本完成了智能电表的改造，采用的是电力线载波通信(Power Line Communication, PLC)技术。智能电表行业已经被PLC占据，NB-IoT基本没有机会。目前，智能电表的需求也仅仅只是，若将来实施实时收费，NB-IoT技术恐怕不能满足实时性的要求。现有的水表和气表市场也面临着国网PLC和双模技术的竞争。国网在积极的推进电、水、热、气四表合一事项，未来NB-IoT到底在抄表市场能够分的多少市场份额实际上具备很大的未知数。 此外，成本价格可能成为NB-IoT发展的阻碍。在成本方面，NB-IoT模组成本未来有望降至5美元之内，但目前支持蓝牙、ZigBee等标准的芯片价格仅在2美元左右，仅支持其中一种标准的芯片价格不到1美元。巨大的价格差距无疑将让企业部署NB-IoT产生顾虑。 物联网应用还处于试验和示范性探索阶段，规模化应用少，创新活力不足。现阶段主要是运营商，华为、爱立信等设备制造商，高通等芯片供应商为代表的供应方比较热情，而需求方的应用主体，如水电气公共服务提供行业还没热络起来。 据相关专家的猜测，物联网行业将会在2018至2019年因为NB-IoT技术和其芯片的商业化迎来再一次的热潮。 芯片厂商在底层芯片领域，当前华为海思、高通、英特尔、MTK、中兴微电子、大唐、展讯等厂商已有NB-IoT芯片的研发计划和实施步骤，原有LTE芯片能力的厂商均可参与，没法形成前2-3家垄断大部分市场，不过由于这一领域的厂商数量并不多，因此也不会形成大量市场参与者，市场集中度会保持在50%以下;而在LoRa阵营中，目前射频芯片供应集中在Semtech一家厂商，占据绝大多数市场份额，从而形成大于80%的市场集中度。 1、华为作为NB-IoT的积极参与者华为而言，NB-IoT是一个大战略，据说华为所有的部门都积极参与其中。 其实早在2014年，华为就斥资2500万美元收购了英国领先的蜂窝物联网芯片和解决方案提供商Neul，还计划以Neul为中心，打造一个全球级物联网。 不出所料，在标准公布后，Neul即将在本月底火速推出NB-IoT商用芯片，这将会是业内第一款正式商用的NB-IoT芯片，而且其芯片价格向短距离通信芯片价格靠近。 据悉，华为推出的NB-IoT芯片在硬币大小的尺寸内集成了BB和AP、Flash和电池管理，并预留传感器集成功能。其中AP包含三个ARM-M0内核，每个M0内核分别负责应用、安全、通信功能，这样在方便进行功能管理的同时降低成本和功耗，后续推出的芯片还将会集成Soft SIM，进一步降低成本。 另外，在九月底提供第一批芯片之后，华为还将会和ublox、移远合作提供第一批的商用模组，商用模组大概是在10月中旬或下旬发布。第一批提供的量并不大，明年年初将大规模商用。 除了芯片以外，华为在NB-IoT领域的布局可谓是全方位覆盖式的。 在今年的世界移动大会物联网峰会上，华为正式面向全球发布了端到端NB-IoT解决方案，主要包括：Huawei Lite OS与NB-IoT芯片使能的智能化终端方案、平滑演进到NB-IoT的eNodeB基站、可支持Core in a Box或NFV切片灵活部署的IoT Packet Core、基于云化架构并具有大数据能力的IoT联接管理平台等，满足了运营商IoT业务低功耗广域覆盖的核心需求。 另外在第二届中国NB-IoT产业联盟高峰论坛上，华为的NB-IoT项目负责人许海平更是表示了华为正在建设的开放实验室将更好地为NB-IoT端到端业务服务。“从今年开始，华为在全球设立了七个开放实验室，现已开放了两个，一个是沃达丰，另外一个是华为的上研所。开放实验室主要是搭建整套的端到端NB-IoT环境，提供NB-IoT的芯片和模组，和一些关系比较密切的合作厂商一起来做端到端的对接，包括芯片模组的集成、后端的联接管理平台、业务服务器的对接等。沃达丰的开放实验室主要是针对的欧洲的合作厂商，上海的实验室主要是针对中国区的，九月份还将在韩国成立一个open lab，意大利等国家也会相继推进。” 2、高通高通认为在未来5年里，从物联网的角度来说，LTE依然是发展基础。3GPP Release 13下引入的NB-IoT将继续随着3GPP的发展而演进，大规模物联网(Massive IoT)所需的低成本、低功耗等将依靠LTE NB-IoT技术从蜂窝连接的方面推动其发展，为物联网5G技术发展打好基础。 高通今年年初推了的MDM 9x07，支持Cat 4，最高支持150Mbps;另外一个是MDM 92071，支持Cat 1的标准;还有去年10月推出的MDM 9206，支持CatM1，后期通过软件升级可以支持NB-IoT。模块OEM厂商预计将于2017年初发布基于MDM 9206、支持Cat M1的模块，而对于Cat NB1的支持预计在此之后不久，通过软件升级的方式实现。另外，在目前的Release 13中，NB-IoT不支持VoLTE，不过在未来的Release 14中，高通就会尝试增加语音功能的支持。随着NBIoT不断演进，高通希望它能为适用于5G的物联网标准打下基础。 运营商从去年开始，包括中国、韩国、欧洲、中东、北美的多家主流运营商已经开展了基于pre-standard 的NB-IoT技术的试点，并开启了端到端的技术和业务验证。 1、中国电信中国电信正在积极跟进NB-IoT技术发展，并正式立项对NB-IoT关键技术、终端和业务开展研发。在具体部署方案上，将基于全覆盖的800M LTE网络部署NB-IoT;基站同时支持LTE和NB-IoT与800MLTE基站共享基带、射频及天馈资源。同时，为了规避可能的频率干扰，并考虑LTE800后续演进的灵活性，优先考虑独立工作模式。 另外，在今年7月召开的“2016年天翼智能终端交易博览会”上，中国电信联合高通、华为、中兴、英特尔、博世、SAP、IBM、爱立信、深创投、中科院上海微系统所、北邮和东南大学12家单位,共同发起成立“天翼物联产业联盟”。 2、中国移动对于中国移动来说，其公众物联网平台自2014年11月底正式商用,截至今年6月,用户已超过2700万。目前，中国移动正加快推进全球统一标准窄带物联网产业成熟和物联网应用创新，构建物联网开放实验室，促进芯片和模组成熟发展，打造一张低成本、低功耗、广覆盖、高可靠的公共物联网，力争2017年实现商用。为了建设NB-IoT物联网，预计在2016年年底至2017年年中，中移动将会获得FDD牌照，并且允许重耕现有的900MHz、1800MHz频段。 3、中国联通中国联通在2015年7月，建成并开放全球第一个NB-IoT新技术示范点;2016年上半年上海迪斯尼物联网启动商用; 2015年-2016年开展了NB-IoT业务试点及试验，目前正推进重点城市(北京、上海、广州、深圳、银川、长沙、福州)的NB-IoT商用部署，计划在2017年实现规模商用，2018年则将开始全面推进国家范围内的商用部署。 中国联通部署在900MHz、1800MHz频段，用于NB-IoT和VoLTE。在900 MHz采用DSSS动态频谱解决方案，在1800MHz连续覆盖区域，部署5MHz带宽的LTE，在没有1800MHz连续覆盖的区域，带宽自动缩窄到 3MHz，但中心频点保持不变，两侧空出的频谱，自动部署14个GSM频点。 相关链接Standardization of NB-IOT completed An Overview Of Narrowband IoT (NB-IoT) 华为 NB-IoT Narrow Band – Internet of Things (NB-IoT) 百度百科","categories":[{"name":"NB-IoT","slug":"NB-IoT","permalink":"http://www.luffyjet.com/techblog/categories/NB-IoT/"}],"tags":[{"name":"NB-IoT","slug":"NB-IoT","permalink":"http://www.luffyjet.com/techblog/tags/NB-IoT/"}],"keywords":[{"name":"NB-IoT","slug":"NB-IoT","permalink":"http://www.luffyjet.com/techblog/categories/NB-IoT/"}]},{"title":"RxJava&Agera资料整理","slug":"RxJava-Agera-articles","date":"2018-03-02T02:43:23.000Z","updated":"2018-12-04T14:35:48.369Z","comments":true,"path":"2018/03/02/RxJava-Agera-articles/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2018/03/02/RxJava-Agera-articles/","excerpt":"RxJava &amp; Agera 从源码简要分析基本调用流程 给 Android 开发者的 RxJava 详解 RxJava 与 Retrofit 结合的最佳实践 深入浅出RxJava（一：基础篇） 系列文章 Learning RxJava for Android by example Awesome-RxJava 资料整理","text":"RxJava &amp; Agera 从源码简要分析基本调用流程 给 Android 开发者的 RxJava 详解 RxJava 与 Retrofit 结合的最佳实践 深入浅出RxJava（一：基础篇） 系列文章 Learning RxJava for Android by example Awesome-RxJava 资料整理 ReactiveX/RxJava文档中文版 RxJava ReactiveX RxJava/wiki 我们为什么要在Android中使用RxJava RxJava开发精要1-从.NET到RxJava RxJava 和 RxAndroid 系列文章 googlesamples/android-architecture 关于RxJava最友好的文章 RxJava 沉思录 reactivex.io/tutorials ReactiveX, RxJava and RxAndroid - where to start grokking-rxjava Rxjava操作符之辩解map和flatmap的区别，以及应用场景","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/tags/RxJava/"}],"keywords":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/categories/RxJava/"}]},{"title":"Android机型判断整理","slug":"android-device-type","date":"2017-12-08T13:20:12.000Z","updated":"2018-12-04T08:24:06.210Z","comments":true,"path":"2017/12/08/android-device-type/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/12/08/android-device-type/","excerpt":"如何识别小米设备/MIUI系统您在开发应用的过程中，可能针对小米手机/MIUI设备的用户有一些特殊的设计，本文档提供了如何识别设备、系统版本和浏览器UA的方法 如何检测小米设备： 请使用android.os.Build对象，查询MANUFACTURER和MODEL的值，MANUFACTURER值为Xiaomi即为小米设备 如何检测MIUI V5： 查询property: ro.miui.ui.version.name ，值是”V5″ 就是MIUI V5系统；值是”V6″就是MIUI 6系统。","text":"如何识别小米设备/MIUI系统您在开发应用的过程中，可能针对小米手机/MIUI设备的用户有一些特殊的设计，本文档提供了如何识别设备、系统版本和浏览器UA的方法 如何检测小米设备： 请使用android.os.Build对象，查询MANUFACTURER和MODEL的值，MANUFACTURER值为Xiaomi即为小米设备 如何检测MIUI V5： 查询property: ro.miui.ui.version.name ，值是”V5″ 就是MIUI V5系统；值是”V6″就是MIUI 6系统。 User-Agent：如果您从事WebApp开发， 可能需要识别浏览器，下面描述了MIUI浏览器的User-Agent : 系统版本号，如: 4.1.1 : 系统的国家地区，如: 中国大陆是zh-cn : 设备型号，如: MI2 : 产品线，如: 小米手机2是JRO03LMozilla/5.0 (Linux; U; Android ; ; Build/) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 XiaoMi/MiuiBrowser/1.0 12345678910111213141516171819202122public class MIUIUtils &#123; // 检测MIUI private static final String KEY_MIUI_VERSION_CODE = \"ro.miui.ui.version.code\"; private static final String KEY_MIUI_VERSION_NAME = \"ro.miui.ui.version.name\"; private static final String KEY_MIUI_INTERNAL_STORAGE = \"ro.miui.internal.storage\"; public static boolean isMIUI() &#123; Properties prop = new Properties(); boolean isMIUI; try &#123; prop.load(new FileInputStream(new File(Environment.getRootDirectory(), \"build.prop\"))); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; isMIUI = prop.getProperty(KEY_MIUI_VERSION_CODE, null) != null || prop.getProperty(KEY_MIUI_VERSION_NAME, null) != null || prop.getProperty(KEY_MIUI_INTERNAL_STORAGE, null) != null; return isMIUI; &#125;&#125; 其他机型引用自：https://www.jianshu.com/p/ba9347a5a05a 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class Rom &#123; private static final String TAG = \"Rom\"; public static final String ROM_MIUI = \"MIUI\"; public static final String ROM_EMUI = \"EMUI\"; public static final String ROM_FLYME = \"FLYME\"; public static final String ROM_OPPO = \"OPPO\"; public static final String ROM_SMARTISAN = \"SMARTISAN\"; public static final String ROM_VIVO = \"VIVO\"; public static final String ROM_QIKU = \"QIKU\"; private static final String KEY_VERSION_MIUI = \"ro.miui.ui.version.name\"; private static final String KEY_VERSION_EMUI = \"ro.build.version.emui\"; private static final String KEY_VERSION_OPPO = \"ro.build.version.opporom\"; private static final String KEY_VERSION_SMARTISAN = \"ro.smartisan.version\"; private static final String KEY_VERSION_VIVO = \"ro.vivo.os.version\"; private static String sName; private static String sVersion; public static boolean isEmui() &#123; return check(ROM_EMUI); &#125; public static boolean isMiui() &#123; return check(ROM_MIUI); &#125; public static boolean isVivo() &#123; return check(ROM_VIVO); &#125; public static boolean isOppo() &#123; return check(ROM_OPPO); &#125; public static boolean isFlyme() &#123; return check(ROM_FLYME); &#125; public static boolean is360() &#123; return check(ROM_QIKU) || check(\"360\"); &#125; public static boolean isSmartisan() &#123; return check(ROM_SMARTISAN); &#125; public static String getName() &#123; if (sName == null) &#123; check(\"\"); &#125; return sName; &#125; public static String getVersion() &#123; if (sVersion == null) &#123; check(\"\"); &#125; return sVersion; &#125; public static boolean check(String rom) &#123; if (sName != null) &#123; return sName.equals(rom); &#125; if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_MIUI))) &#123; sName = ROM_MIUI; &#125; else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_EMUI))) &#123; sName = ROM_EMUI; &#125; else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_OPPO))) &#123; sName = ROM_OPPO; &#125; else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_VIVO))) &#123; sName = ROM_VIVO; &#125; else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_SMARTISAN))) &#123; sName = ROM_SMARTISAN; &#125; else &#123; sVersion = Build.DISPLAY; if (sVersion.toUpperCase().contains(ROM_FLYME)) &#123; sName = ROM_FLYME; &#125; else &#123; sVersion = Build.UNKNOWN; sName = Build.MANUFACTURER.toUpperCase(); &#125; &#125; return sName.equals(rom); &#125; public static String getProp(String name) &#123; String line = null; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec(\"getprop \" + name); input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; Log.e(TAG, \"Unable to read prop \" + name, ex); return null; &#125; finally &#123; if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return line; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}]},{"title":"gitlab安装配置过程记录","slug":"gitlab-setup-record","date":"2017-11-08T04:30:12.000Z","updated":"2018-12-04T08:03:15.149Z","comments":true,"path":"2017/11/08/gitlab-setup-record/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/11/08/gitlab-setup-record/","excerpt":"官方安装指导地址:https://about.gitlab.com/downloads/ 也许会用到的国内镜像https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 按照官方流程执行到下面这一部之前之前，如果需要修改配置，则先修改配置 1sudo gitlab-ctl reconfigure","text":"官方安装指导地址:https://about.gitlab.com/downloads/ 也许会用到的国内镜像https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 按照官方流程执行到下面这一部之前之前，如果需要修改配置，则先修改配置 1sudo gitlab-ctl reconfigure 下面的配置可以将gitlab默认监听的80，8080端口修改为4000，8020端口 12345678vi /etc/gitlab/gitlab.rb添加如下配置，修改nginx监听端口为4000unicorn监听8020unicorn[&apos;listen&apos;] = &apos;127.0.0.1&apos;unicorn[&apos;port&apos;] = 8020 nginx[&apos;listen_port&apos;] = 4000 如果修改的端口没有开启允许对外访问，执行 123456789/sbin/iptables -I INPUT -p tcp --dport 4000 -j ACCEPT #开启4000端口 /etc/rc.d/init.d/iptables save #保存配置 /etc/rc.d/init.d/iptables restart #重启服务 查看端口是否已经开放 /etc/init.d/iptables status 然后继续执行，改命令会自动修改相对应的其他配置文件，并重启各项服务 1sudo gitlab-ctl reconfigure 然后还有头像问题，需要修改 123456789vi /var/opt/gitlab/gitlab-rails/etc/gitlab.yml找到下面的内容，上面的命令默认会生成为80，需要将其端口改成我们设置的 4000gitlab: ## Web server settings (note: host is the FQDN, do not include http://) host: 192.168.1.184 port: 4000 https: false 然后重启服务 123sudo gitlab-ctl restart //重启所有服务sudo gitlab-ctl stop //停止所有服务命令sudo gitlab-ctl start //启动所有服务命令 最后检查端口占用情况 1netstat -apn | grep 4000 打开对应的 服务地址 http://yourhost:4000第一次要求输入密码，然后会转向到登录页。到此完成gitlab安装配置。 gitlab ci runner修改runnervi /etc/gitlab-runner/config.toml注册runnergitlab-ci-multi-runner register 更多命令和配置信息，请前往官方文档","categories":[{"name":"Git","slug":"Git","permalink":"http://www.luffyjet.com/techblog/categories/Git/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://www.luffyjet.com/techblog/tags/gitlab/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://www.luffyjet.com/techblog/categories/Git/"}]},{"title":"前后端数据传输加密简单总结","slug":"rsa_demo","date":"2017-08-13T13:12:20.000Z","updated":"2018-12-04T07:50:55.408Z","comments":true,"path":"2017/08/13/rsa_demo/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/08/13/rsa_demo/","excerpt":"结论：不使用HTTPS，单纯对密码加密传输，是无法保证安全的。写了一个简单的 RSA加密DEMO(包含 Java后台，web前端，Android，iOS)https://github.com/luffyjet/RSAEncSignDemo","text":"结论：不使用HTTPS，单纯对密码加密传输，是无法保证安全的。写了一个简单的 RSA加密DEMO(包含 Java后台，web前端，Android，iOS)https://github.com/luffyjet/RSAEncSignDemo 密码加密传输的一些意义。1、数据库不存原密码，也防止被存原密码； 2、防止数据库被黑后造成密码泄露的问题； 3、hash后的密码格式统一，减少麻烦； 4、防止原密码被利用在其他平台，减少在其他平台的信息泄露（很多用户习惯在其他平台注册时使用相同的密码，太多密码时怕忘记。被抓的hash密码，也就只能在我网站用，其他网站也用不了）； 5、防止原密码暴露，伤害了用户感情（谁都不想自己的密码被人知道）。 web前端的加密手段1.前后端使用RSA加密关键数据。支付类应用使用较为常见。开源RSA加密库jsencrypt 2.验证码结合密码进行MD5加密，可以有效的解决重放问题。参考 3.以上的方式都要配合前端js的混淆加密，增加破解的复杂度，才有意义。参考 Android端的加密手段1.对代码混淆，增加破解难度 2.套壳加固，进一步增加破解难度 3.关键加密代码，用c++编写封装到so,增加破解难度 4.使用加密算法加密请求参数，如：MD5，RSA等，RSA参考 5.使用 HTTPS iOS加密1.对代码混淆，增加破解难度 2.套壳加固，进一步增加破解难度 3.使用加密算法加密请求参数，如：MD5，RSA等 4.使用 HTTPS 几个讨论：Web前端密码加密是否有意义？ 前端如何给 JavaScript 加密","categories":[{"name":"encryption","slug":"encryption","permalink":"http://www.luffyjet.com/techblog/categories/encryption/"}],"tags":[{"name":"rsa","slug":"rsa","permalink":"http://www.luffyjet.com/techblog/tags/rsa/"}],"keywords":[{"name":"encryption","slug":"encryption","permalink":"http://www.luffyjet.com/techblog/categories/encryption/"}]},{"title":"VLC Android 编译流程记录","slug":"vlc_android_build_record","date":"2017-07-25T14:03:41.000Z","updated":"2018-12-04T07:52:06.574Z","comments":true,"path":"2017/07/25/vlc_android_build_record/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/07/25/vlc_android_build_record/","excerpt":"此文基于 VLC-Android 2.1.13 系统环境 123系统：MacOS 10.12.5 (16F73)虚拟机软件：VMware Fusion 专业版 8.0.0 (2985594)Linux镜像：ubuntu-16.04.2-desktop-amd64.iso 官方编译文档：https://wiki.videolan.org/AndroidCompile/ 操作流程： 安装好VMtools 更新系统库","text":"此文基于 VLC-Android 2.1.13 系统环境 123系统：MacOS 10.12.5 (16F73)虚拟机软件：VMware Fusion 专业版 8.0.0 (2985594)Linux镜像：ubuntu-16.04.2-desktop-amd64.iso 官方编译文档：https://wiki.videolan.org/AndroidCompile/ 操作流程： 安装好VMtools 更新系统库 12sudo apt-get updatesudo apt-get upgrade 安装编译VLC所需要的工具 12sudo apt-get install automake ant autopoint cmake build-essential libtool \\ patch pkg-config protobuf-compiler ragel subversion unzip git 安装32位支持 123456sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get dist-upgrade#安装gcc multilabapt-get install gcc-multilib g++-multilib 升级gettext到最新版 v0.19.8.1 12345678下载最新版 latest：http://ftp.gnu.org/gnu/gettext/解压之后编译安装：./configure make sudo make install 升级protobuf到最新 v3.3.0 123456789101112下载C++版： https://github.com/google/protobuf确保编译工具已安装$ sudo apt-get install autoconf automake libtool curl make g++ unzip执行安装流程：$ ./autogen.sh$ ./configure$ make$ make check$ sudo make install$ sudo ldconfig # refresh shared library cache. 安装JDK 12345678910111213我使用的是32位jdk: jdk-8u131-linux-i586.tar.gz解压之后设置环境变量：sudo gedit ~/.bashrc添加下文：#set oracle jdk environmentexport JAVA_HOME=/home/lzc/Android/jdk8export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 刷新环境变量：source ~/.bashrc 安装Android SDK, NDK 1234567891011121314先下载AndroidStudio，我用的：android-studio-ide-162.4069837-linux.zip运行AndroidStudio，然后更新最基本的SDK（level 26，)下载 NDK r13b 即可，无需如文档说的 r14b: https://developer.android.com/ndk/downloads/older_releases.html之后配置环境变量：#android sdk ndkexport ANDROID_SDK=/home/lzc/Android/Sdkexport ANDROID_NDK=/home/lzc/Android/android-ndk-r13bexport PATH=$PATH:$ANDROID_SDK/platform-tools:$ANDROID_SDK/tools刷新环境变量：source ~/.bashrc 开始下载源码进行编译 123456789git clone https://code.videolan.org/videolan/vlc-android.gitcd vlc-android./compile.sh -a armeabi-v7a编译过程中会下载大量依赖(主要是clone VLC项目)，而且其中一些依赖访问需要翻墙。第一次编译量非常大，会出现失败多次，重复运行编译sh即可。编译成功之后，可以将整个目录导入AndroidStudioX86架构的没有需求，暂时没有尝试。","categories":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}],"tags":[{"name":"vlc","slug":"vlc","permalink":"http://www.luffyjet.com/techblog/tags/vlc/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}]},{"title":"Web安全整理","slug":"about-web-security","date":"2017-07-08T14:10:09.000Z","updated":"2018-12-04T07:57:39.555Z","comments":true,"path":"2017/07/08/about-web-security/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/07/08/about-web-security/","excerpt":"Web技术的成熟使得Web应用的功能越来越强大，最终成为了互联网的主流。黑客们的目光，也渐渐转移到了Web这块大蛋糕上。 安全问题的本质是信任的问题。一切安全方案的设计基础，都是建立在信任关系上的。安全三要素，机密性，完整性，可用性 机密性要去保护数据内容不能泄露，加密是实现机密性要求的常见手段。 完整性则要求保护数据内容是完整、没有被篡改的。常见的保证一致性的技术手段是数字签名。 可用性要求保护资源是“随需而得”。","text":"Web技术的成熟使得Web应用的功能越来越强大，最终成为了互联网的主流。黑客们的目光，也渐渐转移到了Web这块大蛋糕上。 安全问题的本质是信任的问题。一切安全方案的设计基础，都是建立在信任关系上的。安全三要素，机密性，完整性，可用性 机密性要去保护数据内容不能泄露，加密是实现机密性要求的常见手段。 完整性则要求保护数据内容是完整、没有被篡改的。常见的保证一致性的技术手段是数字签名。 可用性要求保护资源是“随需而得”。 实施安全评估一个安全评估的过程，可以简单地分为4个阶段：资产等级划分，威胁分析，风险分析，确认解决方案。实施的过程是层层递进，前后之间有因果关系。 资产等级划分，帮助我们明确目标是什么，要保护什么。对互联网公司拥有的资产进行等级划分，就是对数据做等级划分。每家公司的侧重点可能不同。互联网安全的核心问题，是数据安全的问题。 威胁分析，就是把所有的威胁都找出来。可以参考微软的STRIDE模型。 风险分析，可以参考微软的 DREAD模型。 安全评估的产出物，就是安全解决方案。一个优秀的安全方案应该具备：能有效的解决问题，用户体验好，高兴呢，低耦合，易于扩展和升级。 客户端脚本安全包含 浏览器安全 跨站脚本攻击(XSS) 跨站点请求伪造(CSRF) 点击劫持(ClickJacking) HTML5安全 1.浏览器安全浏览器是目前互联网最大的入口。浏览器具备许多安全功能。 同源策略(same origin policy)是一种约定，是浏览器最核心也是最基本的安全功能。浏览器的同源策略，限制了不同源的document或JavaScript脚本，对当前document读取或设置某些属性。 对于JavaScript，影响源的因素有：host(域名或IP，ip地址当做根域名)、子域名、端口、协议(例如http和https)。 浏览器中，“script img iframe link” 等标签都能可以跨域加载资源，不受同源策略限制。XMLHttpRequest受到同源策略的约束，不能跨域访问资源。跨域访问方案的安全基础就是信任 “JavaScript无法控制该HTTP头”。 浏览器沙箱 Sandbox采用沙箱技术，无疑可以让不受信任的网页代码、JavaScript代码运行在一个受限制的环境中，从而保护本地桌面系统的安全。 恶意网站拦截浏览器周期性的从服务器获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。除了恶意网站拦截功能外，主流浏览器都开始支持EVSSL证书(Extended Validation SSL Certificate)，以增强对安全网站的识别。EV证书在浏览器上会有特殊的效果，比如绿色的标识。 浏览器的安全以同源策略为基础，加深理解同源策略，才能把握住浏览器安全的本质。 2.跨站脚本攻击(XSS)跨站脚本攻击，全称Cross Site Script。为了和层叠样式表有所区别，所以在安全领域叫做XSS。XSS攻击，通常指黑客通过“html 注入”篡改了网页，插入了恶意脚本，从而在用户浏览器网页是，控制用户浏览器的一种攻击。XSS根据效果可以分成3种类型： 反射型XSS，反射型XSS只是简单的把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户点击一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”。 存储型XSS，存储型XSS会把用户输入的数据“存储”在服务端，这种XSS有很强的稳定性。存储型XSS通常也叫做“持久型XSS”。 DOM Based XSS,通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。 XSS进阶攻击： XSS playload ，XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户浏览器。XSS playload实际上就是JavaScript脚本，所以任何JavaScript脚本能做的事，XSS playload都能做到。 XSS蠕虫 XSS 实例查看： http://www.cnblogs.com/leestar54/p/5798937.html#top http://blog.csdn.net/kevon_sun/article/details/51135880 XSS攻击平台这些平台的主要目的是演示XSS的危害,有助于深入理解XSS的原理和危害： Attack API BeEF XSS-Proxy XSS的攻击手段和技巧，还有很多，具体可以参考《白帽子讲web安全》一书。 XSS防御 设置HttpOnly，禁止JavaScript访问带有httponly属性的cookie。 输入输出检查 安全的编码函数 处理富文本 防御DOM Based XSS 实例参考：http://www.cnblogs.com/digdeep/p/4695348.html 3.跨站点请求伪造(CSRF)CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。原理和防御方法参考：http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html 4.点击劫持点击劫持，clickjacking，也被称为UI-覆盖攻击。这个词首次出现在2008年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了HTML中 iframe 标签的透明属性。 攻击和防御参考实例：http://www.freebuf.com/articles/web/67843.html 5.HTML5安全HTML5新增的标签和功能，可能带来新的XSS攻击。该网站 http://html5sec.org/ 列举了大部分的攻击方式。 服务器端应用安全 注入攻击 文件上传漏洞 认证与会话管理 访问控制 加密算法与随机数 Web框架安全 应用层拒绝服务攻击 webserver 配置安全 1.注入攻击SQL注入SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编程时的疏忽，通过SQL语句，实现无帐号登录，甚至篡改数据库。攻击手段示例和防御方法参考：http://www.cnblogs.com/baizhanshi/p/6002898.html XML注入http://blog.csdn.net/mevicky/article/details/48239481 代码注入http://blog.csdn.net/hitwangpeng/article/details/45716821 CRLF注入http://www.2cto.com/article/201406/312590.html 2.文件上传漏洞文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本获得了执行服务器端命令的能力。文件上传后导致的常见安全问题一般有： 上传文件是web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行； 上传文件是Flash的策略文件crossdomain.xml,黑客用以控制flash在该域下的行为(其他通过类似方式控制策略文件的情况类似)； 上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行； 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。 大多数情况下，文件上传漏洞一般都是指“上传web脚本能够被服务器解析”的问题,也就是通常所说的webshell，要完成这个攻击，要满足几个条件： 首先，上传的文件能够被web容器解释执行； 其次，用户能够从web上访问这个文件； 最后，用户上传的文件若被安全检查，格式化，图片压缩等功能改变了内容，则也可能导致攻击不成功。 攻击实例：http://www.cnblogs.com/crazylocust/p/6759529.html 防御手段： 文件上传的目录设置为不可执行 判断文件类型 使用随机数改写文件名和文件路径 单独设置文件服务器的域名 3.认证与会话管理认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。 密码的合理保存方式：将明文密码经过哈希后再保存到数据库，在计算哈希值时，增加一个“salt”，salt是一个字符串，作用是增加明文哈希值的复杂度，并使得彩虹表一类的攻击失效。 多因素认证：对于很多重要的系统，如果只有密码作为唯一的认证手段，从安全上看会略显不足，因此为了增强安全性， 大多数网上银行和网上支付平台都会采用双因素认证或多因素认证。 session fixation 攻击：用户登录网站的过程中，如果登录前后用户的sessionID没有发生变化，则会存在session fixation问题。 session 保持攻击:一般来说session是有生命周期的，当用户长时间未活动，或者用户退出，服务器将销毁session。如果攻击者能一直持有一个有效的session，而服务器对于活动的session一直不销毁的话，攻击者就能通过此有效session一直使用用户的账号，成为一个永久的后门。攻击者可以通过不停的发起访问请求，让session一直活下去，比如不停的刷新页面。如何对抗这种session保持攻击，常见的做法是在一定的时间后， 强制销毁session。但是强制销毁可能会影响到一些正常的用户，还可以选择的方法是在当用户客户端发生变化时，要求用户重新登录。比如用户的IP、useragent等信息发生了变化，就可以强制销毁当前的session，并要求用户重新登录。 单点登录(SSO):英文全称，single sign on，简称sso。它希望用户只需要登录一次，就可以访问所有系统。从用户体验的角度看，sso无疑让用户的使用更加的方便，从安全角度看，sso把风险集中在单点上，这样做是有利有弊的。利是风险集中，缺点是风险集中了，所以单点一旦被攻破，后果会非常严重。 4.访问控制web安全领域中，权限控制的问题都可以归纳为访问控制的问题。 访问控制实际上是建立用户与权限之间的对应关系，现在应用广泛的一种方法，就是基于角色的访问控制(Role-Based Access Control)，简称RBAC。RBAC事先会在系统中定义出不同的角色，不同的角色拥有不同的权限，一个角色实际上就是一个权限的集合，而系统的所有用户都会被分配到不同的角色中，一用户可能拥有多个角色，角色之间有权限高低之分。在系统验证权限时，只需要验证用户所属角色，然后就可以根据角色所拥有的权限进行授权了。 RBAC属于垂直权限管理，在RBAC下，系统只会验证用户A是否属于角色RoleX，而不会判断用户A是否能否访问只属于用户B的数据DataB，用户B和用户A是属于同一角色的。因此发生了越权访问。这种问题，我们就称之为“水平权限管理问题”。此问题难以在统一框架下解决。 OAuth 是一个在不提供用户名和密码的情况下，授权第三方应用访问web资源的安全协议。 具体说明和参考： http://www.tuicool.com/articles/qqeuE3 http://blog.jobbole.com/49211/ 5.加密算法和随机数常见的加密算法通常分为分组加密算法与流密码加密算法两种，两者实现原理不同。分组加密算法基于“分组”(block)进行操作，根据算法的不同， 每个分组的长度可能不同。分组加密算法的代表有DES，3-DES，Blowfish，IDEA，AES等。流密码加密算法，则每次只处理一个字节，密钥独立于消息之外，两者通过异或实现加密与解密。流密码加密算法的代表有RC4,ORYX，SEAL等。 针对加密算法的攻击，一般根据攻击者能获得的信息，可以分为： 唯密码攻击，攻击者有一些密文，它们是使用同一加密算法和同一密钥加密的。这种攻击是最难的。 已知明文攻击，攻击者除了能得到一些密文外，还能得到这些密文对应的明文。本章中针对流密码的一些攻击为已知明文攻击。 选择明文攻击，攻击者不仅能得到一些密文和明文，还能选择用于加密的明文。 选择密文攻击，攻击者可以选择不同的密文来解密。 Reused Key Attack在流密码的使用中，最常见的错误便是使用同一个密钥进行多次加/解密。这将使得破解流密码变得非常简单。在这种攻击下，攻击者不需要知道，密钥，即可还原出明文。 常见的加密模式有：ECB，CBC，CFB，OFB，CTR等。 对于web应用来说，密钥管理，常见的做法是将密钥(包括密码)保存在配置文件或者数据库中。 其他更多的攻击手段和案例参考《白帽子讲web安全》。 加密算法的选择和使用的最佳实践： 1.不要使用ECB模式 2.不要使用流密码(比如RC4) 3.使用HMAC-SHA1代替MD5(甚至是代替SHA1) 4.不要使用相同的key做不同的时期 5.salt与IV需要随机产生 6.不要自己实现加密算法，尽量使用安全专家已经实现好的库 7.不要依赖系统的保密性 当你不知道如何选择时，有一下建议： 1.使用CBC模式的AES256用于加密 2.使用HMAC-SHA512用于完整性检查 3.使用带salt的SHA-256或SHA-512用于Hashing。 6.web框架安全在框架中实施安全方案，比由程序员在业务中修复一个个具体的bug,有着更多的优势。 模板引擎与XSS防御，在View层，可以解决XSS问题。使用“输出编码” 的防御方法，针对不同的情况使用不同的编码函数。 在web框架中可以使用security token解决CSRF攻击，在web开发中，对“读操作”和“写操作”予以区分，比如所有的“写操作”都使用Http post。 参考：Spring MVC防御CSRF、XSS和SQL注入攻击 此外还有web框架本身的安全漏洞。 Web 应用安全利器：IBM Rational AppScanIBM Rational AppScan 是一个全面的 Web 应用安全解决方案，为 Web 及 Web 2.0 应用提供了安全漏洞扫描、报告和修复建议等功能，可以帮助开发者全面准确地发现并解决安全问题。 7.应用层拒绝服务攻击DDOS又称为分布式拒绝服务，常见的DDOS攻击有SYN flood，UDP flood，ICMP flood等。应用层DDOS攻击是针对服务器性能的一种攻击，那么许多优化服务器性能的方法，或多或少地能缓解此种攻击。常见的防御措施： 限制请求频率，在应用中，针对每个“客户端”做一个请求频率的限制。 应用代码做好性能优化 网络架构上做好优化，利用好负载均衡和CDN。 实现一些对抗手段，比如限制每个IP的请求频率 加入验证码 CC攻击：Challenge Collapasar,意值在黑洞(一款反DDOS设备)的防御下，仍然能有效的完成拒绝服务攻击。CC攻击的原理就是对一些消耗资源较大的应用页面不断的发起正常的请求，以达到消耗服务器资源的目的。 资源耗尽攻击 slowloris攻击，原理是以极低的速度往服务器发送http请求，由于webserver对于并发的连接数都有一定的上限，因此若是恶意的占用住这些连接不放，那么webserver的所有连接都将被恶意连接占用，从而无法接受新的请求，导致拒绝服务。 http post dos,原理是在发送http post包时，指定一个非常大的content-length值，然后以很低的速度发包，比如10~100s发一个字节，保持住这个连接不断开。这样客户端连接数多了以后，占用住了webserver的所有可用连接，从而导致DOS。 如何防御DDOS攻击? 8.WebServer配置安全web服务器是web应用的载体，如果这个载体出现安全问题，那么运行在其中的web应用程序的安全也无法得到保障。 Apache安全 Nginx安全 Tomcat安全配置","categories":[{"name":"Web","slug":"Web","permalink":"http://www.luffyjet.com/techblog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.luffyjet.com/techblog/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.luffyjet.com/techblog/categories/Web/"}]},{"title":"iOS资源整理","slug":"iOS-resource","date":"2017-05-19T14:12:02.000Z","updated":"2018-12-04T08:17:10.760Z","comments":true,"path":"2017/05/19/iOS-resource/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/05/19/iOS-resource/","excerpt":"","text":"Bloghttp://blog.devtang.com/ https://onevcat.com/#blog http://blog.cnbang.net/ http://blog.ibireme.com/ 开源库http://awesomeios.com/ https://github.com/dkhamsing/open-source-ios-apps","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.luffyjet.com/techblog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.luffyjet.com/techblog/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://www.luffyjet.com/techblog/categories/iOS/"}]},{"title":"Spring 集成 Mybatis记录","slug":"spring-migration-mybatis ","date":"2017-05-12T13:23:15.000Z","updated":"2018-12-04T08:57:38.536Z","comments":true,"path":"2017/05/12/spring-migration-mybatis /","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2017/05/12/spring-migration-mybatis /","excerpt":"基于IDEA+Gradle构建 首先需要依赖 compile &quot;org.mybatis:mybatis-spring:${mybatisSpringVersion}&quot; Spring配置数据源,有三种，选择dbcp库 1234567891011121314151617181920212223&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;","text":"基于IDEA+Gradle构建 首先需要依赖 compile &quot;org.mybatis:mybatis-spring:${mybatisSpringVersion}&quot; Spring配置数据源,有三种，选择dbcp库 1234567891011121314151617181920212223&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; 配置mapper和xml 1234567891011121314151617&lt;!--获取sqlSession，并指定sqlmapper目录--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;config/mybatis/mapper/*.xml&quot; /&gt;&lt;/bean&gt;&lt;!--自动扫描mapper--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.luffyjet.gweb.mapper&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;&lt;!--事务--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 参考mybatis blog MyBatis 文档中文版 MyBatis-Spring 中文文档 官方Demo/jpetstore-6 spring-framework-reference/jdbc http://blog.csdn.net/jiuqiyuliang/article/details/45132493/ 自动生成代码MyBatis Generator 中文文档 MyBatis通用Mapper3 Mybatis-Spring 示例 Mybatis通用分页插件 Mybatis-PageHelper","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.luffyjet.com/techblog/categories/Spring/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.luffyjet.com/techblog/tags/mybatis/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://www.luffyjet.com/techblog/categories/Spring/"}]},{"title":"RxJava Observer与Subscriber","slug":"RxJava-Observer-Subscriber","date":"2016-10-30T02:43:23.000Z","updated":"2018-12-04T07:52:58.440Z","comments":true,"path":"2016/10/30/RxJava-Observer-Subscriber/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2016/10/30/RxJava-Observer-Subscriber/","excerpt":"结论建议每次subscribe()都new一个新的Subscriber或者是使用Observer，也就是不要重复使用mSubscriber。 为什么","text":"结论建议每次subscribe()都new一个新的Subscriber或者是使用Observer，也就是不要重复使用mSubscriber。 为什么 Subscriber是Observer的实现类，Observer 和 Subscriber 具有相同的角色，而且 Observer 在 subscribe() 过程中最终会被转换成 Subscriber 对象。 12345678910111213141516171819202122232425262728293031323334public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123; if (observer instanceof Subscriber) &#123; return subscribe((Subscriber&lt;? super T&gt;)observer); &#125; if (observer == null) &#123; throw new NullPointerException(\"observer is null\"); &#125; return subscribe(new ObserverSubscriber&lt;T&gt;(observer)); &#125; ------------------------------------------------- public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123; final Observer&lt;? super T&gt; observer; public ObserverSubscriber(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; observer.onNext(t); &#125; @Override public void onError(Throwable e) &#123; observer.onError(e); &#125; @Override public void onCompleted() &#123; observer.onCompleted(); &#125;&#125; Subscriber和Observer作为成员变量,比如 mSubscriber, mObserver传入 subscribe() 会有所区别。mSubscriber 传入之后，会被赋值成SafeSubscriber实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SafeSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123; private final Subscriber&lt;? super T&gt; actual; boolean done; public SafeSubscriber(Subscriber&lt;? super T&gt; actual) &#123; super(actual); this.actual = actual; &#125; @Override public void onCompleted() &#123; if (!done) &#123; done = true; try &#123; actual.onCompleted(); &#125; catch (Throwable e) &#123; // we handle here instead of another method so we don't add stacks to the frame // which can prevent it from being able to handle StackOverflow Exceptions.throwIfFatal(e); RxJavaHooks.onError(e); throw new OnCompletedFailedException(e.getMessage(), e); &#125; finally &#123; // NOPMD try &#123; // Similarly to onError if failure occurs in unsubscribe then Rx contract is broken // and we throw an UnsubscribeFailureException. unsubscribe(); &#125; catch (Throwable e) &#123; RxJavaHooks.onError(e); throw new UnsubscribeFailedException(e.getMessage(), e); &#125; &#125; &#125; &#125; @Override public void onError(Throwable e) &#123; // we handle here instead of another method so we don't add stacks to the frame // which can prevent it from being able to handle StackOverflow Exceptions.throwIfFatal(e); if (!done) &#123; done = true; _onError(e); &#125; &#125; @Override public void onNext(T args) &#123; try &#123; if (!done) &#123; actual.onNext(args); &#125; &#125; catch (Throwable e) &#123; // we handle here instead of another method so we don't add stacks to the frame // which can prevent it from being able to handle StackOverflow Exceptions.throwOrReport(e, this); &#125; &#125; ... ...&#125; 通过SafeSubscriber源码可知 onCompleted 执行后会给成员变量 done 赋值true,并自动unsubscribe(),通过成员变量 done 判断是否执行 onNext(),onError()等，所以subscribe()传入mSubscriber只有第一次能正常使用。传入mObserver则没有这个问题，它每次都会自动创建新的Subscriber来包装它一次。如果使用subscribe(new Subscriber&lt; T&gt;(){}）方式实现订阅，也不会出现上面的问题。","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/tags/RxJava/"}],"keywords":[{"name":"RxJava","slug":"RxJava","permalink":"http://www.luffyjet.com/techblog/categories/RxJava/"}]},{"title":"Android6.0权限处理","slug":"android6.0-permissions","date":"2016-05-09T04:30:33.000Z","updated":"2018-12-04T14:34:11.158Z","comments":true,"path":"2016/05/09/android6.0-permissions/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2016/05/09/android6.0-permissions/","excerpt":"开源项目 AndPermission Android 6.0 运行时权限处理完全解析 Android 6.0 - 动态权限管理的解决方案 开源项目 PermissionsDispatcher PermissionGen MPermissions codekk.com 搜权限 https://github.com/tbruyelle/RxPermissions https://github.com/anthonycr/Grant","text":"开源项目 AndPermission Android 6.0 运行时权限处理完全解析 Android 6.0 - 动态权限管理的解决方案 开源项目 PermissionsDispatcher PermissionGen MPermissions codekk.com 搜权限 https://github.com/tbruyelle/RxPermissions https://github.com/anthonycr/Grant 正常权限123456789101112131415161718192021222324252627282930313233343536As of API level 23, the following permissions are classified as PROTECTION_NORMAL:ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINSTALL_SHORTCUTINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_IGNORE_BATTERY_OPTIMIZATIONSREQUEST_INSTALL_PACKAGESSET_ALARMSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUNINSTALL_SHORTCUTUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGS 危险权限1234567891011121314151617181920212223242526272829303132333435363738394041CALENDAR READ_CALENDARWRITE_CALENDARCAMERA CAMERACONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTSLOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATIONMICROPHONE RECORD_AUDIOPHONE READ_PHONE_STATECALL_PHONEREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLSSENSORS BODY_SENSORSSMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMSSTORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE","categories":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}],"tags":[{"name":"Permissions","slug":"Permissions","permalink":"http://www.luffyjet.com/techblog/tags/Permissions/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://www.luffyjet.com/techblog/categories/Android/"}]},{"title":"Android调试自测工具01 (Hugo、Timber、Scalpel)","slug":"android-debug-tools-hugo-scalpel-timber","date":"2015-04-10T02:43:23.000Z","updated":"2016-11-09T06:54:05.000Z","comments":true,"path":"2015/04/10/android-debug-tools-hugo-scalpel-timber/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2015/04/10/android-debug-tools-hugo-scalpel-timber/","excerpt":"三个工具都出自JakeWharton大神。hugo和timber用于打印Log, scalpel用于在3D下查看界面的图层。 Hugo做项目的时候有时候需要打印方法的传参和返回值，甚至方法的执行时间，有没有一种简单方便通用的方式去做这个呢，Hugo就可以。使用方法很简单，Hugo是基于注解被调用的，引入相关依赖后，在方法上加上 @DebugLog 即可。也可以加在内部类上。 我没研究在Eclipse下怎么引入这个东西，用Eclipse的同志趁早转投AndroidStudio吧。AndroidStudio下引入Hugo很方便，添加两行代码即可。 先看看打印的效果图：","text":"三个工具都出自JakeWharton大神。hugo和timber用于打印Log, scalpel用于在3D下查看界面的图层。 Hugo做项目的时候有时候需要打印方法的传参和返回值，甚至方法的执行时间，有没有一种简单方便通用的方式去做这个呢，Hugo就可以。使用方法很简单，Hugo是基于注解被调用的，引入相关依赖后，在方法上加上 @DebugLog 即可。也可以加在内部类上。 我没研究在Eclipse下怎么引入这个东西，用Eclipse的同志趁早转投AndroidStudio吧。AndroidStudio下引入Hugo很方便，添加两行代码即可。 先看看打印的效果图： 配置的流程： Project级别的build.gradle dependencies 内加入 dependencies { classpath &apos;com.android.tools.build:gradle:1.1.0&apos; classpath &apos;com.jakewharton.hugo:hugo-plugin:1.2.1&apos; } Module级别的build.gradle 顶部加入 apply plugin: &apos;com.jakewharton.hugo&apos; 然后代码中加入注解即可 12345678910111213141516171819202122232425@DebugLogprivate int fibonacci(int number) &#123; if (number &lt;= 0) &#123; throw new IllegalArgumentException(\"Number must be greater than zero.\"); &#125; if (number == 1 || number == 2) &#123; return 1; &#125; // NOTE: Don't ever do this. Use the iterative approach! return fibonacci(number - 1) + fibonacci(number - 2);&#125; @DebugLogclass Charmer &#123; private final String name; Charmer(String name) &#123; this.name = name; &#125; public String askHowAreYou() &#123; return \"How are you \" + name + \"?\"; &#125;&#125; TimberTimber其实就是对Android的Log类进行封装后的一个Log工具，平时我自己也有封装过，不过大神的封装非常优雅。Timber只有一个类文件，可以单独把它复制出来放项目里，也可以通过Gradle引用：​ compile ‘com.jakewharton.timber:timber:2.7.1’ Timber使用的时候推荐在Application类中初始化，比如： 123456789101112public class DemoApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (BuildConfig.DEBUG) &#123; Timber.plant(new Timber.DebugTree()); &#125; else &#123; Timber.plant(new CrashReportingTree()); &#125; &#125; &#125;&#125; Timber.plant（Tree tree）用来给Timber设置用于打印的实现类，Tree是个接口，DebugTree是Timber中已经实现了tree的类，可直接拿来用。Timber中还有个HollowTree的类用于扩展，比如上面的CrashReportingTree，我们可以把崩溃打印进行一些处理。使用的时候调用静态方法即可： 1234Timber.tag(\"LifeCycles\");//设置只能用一次的TagTimber.d(\"Activity Created\"); //DebugTree 会帮你进行格式化输出Timber.i(\"A button with ID %s was clicked to say '%s'.\", id, messag); 其他的查看源码吧。 Scalpel这个可以查看界面的图层，3D的效果，不像开发者选项中 开启显示布局边界 是平面的线框。用AndroidStudio 引用只要在 build.gradle添加 1compile &apos;com.jakewharton.scalpel:scalpel:1.1.2&apos; 使用的时候你的layout根节点必须是 ScalpelFrameLayout , ScalpelFrameLayout有以下几个常用方法： 开启3D效果 ： setLayerInteractionEnabled(boolean). 显隐DrawViews：setDrawViews(boolean). 显隐 view ID： setDrawIds(boolean). 修改边框的颜色和阴影 setChromeColor(int) and setChromeShadowColor(int). 手势操作的方法： 单指用来旋转整个模型 双指垂直收缩来调整模型大小 双指水平收缩来调整每个图层间的间距 效果图：","categories":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://www.luffyjet.com/techblog/tags/debug/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}]},{"title":"Facebook Stetho 使用学习","slug":"facebook-stetho-okhttp-study","date":"2015-04-08T07:39:46.000Z","updated":"2016-03-25T06:04:42.000Z","comments":true,"path":"2015/04/08/facebook-stetho-okhttp-study/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2015/04/08/facebook-stetho-okhttp-study/","excerpt":"今年年初，facebook开源了一个Android开发调试工具，叫stetho，应该是单词stethoscope的一部分吧，意为诊断器。 代码托管地址： https://github.com/facebook/stetho 在项目中添加相应代码，通过Chrome DevTools连接设备后具备以下功能： 可以在Chrome里进行网络访问检测，可以查看请求链接，请求头，JSON数据等 不root的情况下查看Sqlite数据库，并且可以使用sql语句去操作 最近又升级了，API 15 以上能查看View hierarchy了 dumpapp 工具提供强大的命令行接口来访问应用内部 更新比较频繁，前几天更新到1.1.0了，使用AndroidStudio可以很方便的添加到项目中。当然也可以从github页面下载最新Jar包。","text":"今年年初，facebook开源了一个Android开发调试工具，叫stetho，应该是单词stethoscope的一部分吧，意为诊断器。 代码托管地址： https://github.com/facebook/stetho 在项目中添加相应代码，通过Chrome DevTools连接设备后具备以下功能： 可以在Chrome里进行网络访问检测，可以查看请求链接，请求头，JSON数据等 不root的情况下查看Sqlite数据库，并且可以使用sql语句去操作 最近又升级了，API 15 以上能查看View hierarchy了 dumpapp 工具提供强大的命令行接口来访问应用内部 更新比较频繁，前几天更新到1.1.0了，使用AndroidStudio可以很方便的添加到项目中。当然也可以从github页面下载最新Jar包。 Chrome DevTools 需要科学上网(fanqiang),否则点 inspect 会出一直是一块白板。（或者寻求其他方法解决）要在项目中启动Stetho很方便，按照官方的说明： 添加初始化的代码到Application内，完成这一步就具备查看数据库，查看View层级结构，使用默认dumpapp工具的能力了 public class MyApplication extends Application { public void onCreate() { super.onCreate(); Stetho.initialize(Stetho.newInitializerBuilder(this) .enableDumpapp(Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(this)).build(); } } 开启网络检测，有两种方式 使用HttpURLConnection有些麻烦，可以参考我提供的DEMO的代码（在正文最底下），需要用到另一个依赖 stetho-urlconnection 如果用的目前超流行的 OkHttp 则非常方便，给OkHttpClient 设置一个StethoInterceptor 即可,需要另一个依赖 stetho-okhttp OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); 如果用了Retrofit这个开源项目，也可以很方便的进行设置，同样需要另一个依赖 stetho-okhttp OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); RestAdapter adapter = new RestAdapter.Builder().setClient(new OkClient(client)).setEndpoint(BASE_URL).buid(); 自定义 dumpapp 可以参考我提供的DEMO的代码，值得注意的是 该工具只能运行在 类Unix环境下，比如Linux和Mac。 效果截图（点击可查看大图） 网络请求监测 查看与操作sqlite操作效果 查看与操作sharedpreference 在Chrome上查看View的层级 在上图显示的层级中我选中Actionbar后，手机上也会显示被选中的位置 http请求头查看 json数据查看 最后附上我的 DEMO APK Source Code","categories":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://www.luffyjet.com/techblog/tags/debug/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}]},{"title":"开源许可协议学习","slug":"open-source-licenses-study","date":"2015-04-08T04:03:41.000Z","updated":"2016-03-25T05:39:36.000Z","comments":true,"path":"2015/04/08/open-source-licenses-study/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2015/04/08/open-source-licenses-study/","excerpt":"一直在用开源代码，但是对于那些 开源许可协议 了解太少，惭愧。 关于几个主流协议间的区别，一图顶千言： GitHub上开源项目协议使用情况： 由图可以看出 MIT 限制是最宽松的，其可谓为所欲为，因此使用量也是最大的。当然图中的协议不全，还有比GPL更严格的协议AGPL。每个协议的具体内容，我看不懂，能区别他们就好。要商用的软件就不能采用带GPL系列许可证的，不过在中国这方面就… 以下是具体的介绍，文字均来源于网络。 什么是软件许可协议？","text":"一直在用开源代码，但是对于那些 开源许可协议 了解太少，惭愧。 关于几个主流协议间的区别，一图顶千言： GitHub上开源项目协议使用情况： 由图可以看出 MIT 限制是最宽松的，其可谓为所欲为，因此使用量也是最大的。当然图中的协议不全，还有比GPL更严格的协议AGPL。每个协议的具体内容，我看不懂，能区别他们就好。要商用的软件就不能采用带GPL系列许可证的，不过在中国这方面就… 以下是具体的介绍，文字均来源于网络。 什么是软件许可协议？ 关于究竟什么是许可协议的问题上有很多事实而非的说法。当你给软件附上许可证时，意味着你将保留对软件的所有权利。你将对你的作品拥有原创版权(或者是专利权，如果你申请到了)。许可协议用来授权其他人具有某种使用你的作品的权利。 &#160; &#160; &#160; &#160; 依靠许可协议将你的作品对外开源或者对你的作品的各个方面逐一进行授权，是一个不错的方法。一旦对外开源，你将失去所有对你的作品的版权，别人也没有义务将你标注为作品的原创者或捐献者。而我说的后一种情况里，估计你需要从设计和开发的工作中抽出更多的时间来处理遇到的各种侵权问题。 &#160; &#160; &#160; &#160; 开源许可协议 使人们免去了研究那些专业的许可条款的麻烦，使人们更方便的对开源项目贡献出自己的代码。而且它还能保护你作为作品的原创作者，确保你至少拥有由于贡献参与而带来的署名荣誉。它还能用来阻止其他人企图声明对你的作品拥有所有权的行为。 常见开源许可协议：GPL、LGPL、BSD、Apache License 2.0、MIT等GPL&#160; &#160; &#160; &#160; 全称 GNU General Public License。它的主要内容为：只要在一个软件中使用(“使用”指类库引用或者修改后的代码) GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这个协议就不太适合商用软件，或者准备使用GPL开源组件的商用项目。基于这个协议的项目，极大的提高了开源软件的数量。上面那个微博的案例，如果作者使用了GPL协议，而使用方没有公开源代码就是违反了协议。目前用的多的是GPLV1，GPLV2。这两个什么区别看后面那张树形图。采用这个协议的开源软件有：Linux、 MySQL. LGPL&#160; &#160; &#160; &#160; 最初是Library GPL的缩写，后来改称作Lesser GPL。由于GPL太严格，限制了很多商用软件使用GPL组件才推出了这个LGPL。LGPL允许商业软件通过引用类库的方式使用LGPL组件（不直接使用源代码），这样可以不需要开源商业软件的代码。但是如果要修改原始组件的代码，则涉及修改部分的代码和基于原来代码衍生的代码都必须采用LGPL协议。LGPL不适合以LGPL协议为基础的代码进行二次开发的商业软件，但是商用软件可以采用编译后的类库引用就不需要公开源代码了。采用这个协议的开源软件有： JBoss、 FCKeditor 、 Hibernate。之前extjs就因为从LGPL转换到GPL带来了不少的震动。详情点击。 BSD&#160; &#160; &#160; &#160; 全称 Berkeley Software Distribution。这个协议相对上面两个协议宽松很多，允许使用者修改和重新发布代码，也允许使用或在BSD代码基础上开发商业软件发布和销售，因此是适用于商业软件的。使用者别太高兴，使用时还必须做到满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。使用用BSD协议的开源软件有： nginx、CruiseControl、Redis… Apache License 2.0&#160; &#160; &#160; &#160; 这个协议除了为用户提供版权许可之外，还有专利许可。与BSD协议权限类似， 允许代码修改，再发布，适用商业软件。但是也需要满足以下条件： 需要给代码的用户一份Apache Licence。 如果你修改了代码，需要再被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 除了这些条件它还有这些好处： 永久权利 一旦被授权，永久拥有。 全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。 授权免费 无版税， 前期、后期均无任何费用。 授权无排他性 任何人都可以获得授权 授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码 使用Apache License 2.0协议的开源软件有：Hadoop、SpringFramework、MongoDB… MIT&#160; &#160; &#160; &#160; 源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 扩展阅读流行的开源许可协议经过Open Source Initiative 组织批准的开源协议](http://opensource.org/licenses/alphabetical)[开源软件及国内发展现状做一个优秀的开源项目，需要注意哪些方面？","categories":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://www.luffyjet.com/techblog/categories/OpenSource/"}],"tags":[{"name":"OpenSourceLicenses","slug":"OpenSourceLicenses","permalink":"http://www.luffyjet.com/techblog/tags/OpenSourceLicenses/"}],"keywords":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://www.luffyjet.com/techblog/categories/OpenSource/"}]},{"title":"Retrofit的科学使用：Singleton ","slug":"retrofit-singleton-usage","date":"2014-12-30T02:43:23.000Z","updated":"2016-11-07T11:42:32.000Z","comments":true,"path":"2014/12/30/retrofit-singleton-usage/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2014/12/30/retrofit-singleton-usage/","excerpt":"单例模式很适合Android开发，对于Retrofit(Android开发中一个非常优秀的Rest Client)，也要使用单例模式获取实例。 下面是Jake大神在stackoverflow上关于Retrofit的使用问题的回答。 Both the RestAdapter and the generated instance of your services (MyTaskService in this case) are extremely expensive objects and should be used as singletons. This means that you should only ever call restAdapter.create once and re-use the same instance of MyTaskService every time you need to interact with. I cannot stress this enough. You can use the regular singleton pattern in order to ensure that there only is ever a single instance of these objects that you use everywhere. A dependency injection framework would also be something that could be used to manage these instances but would be a bit overkill if you are not already utilizing it. 从中我们可以看到 Jake表示 Retrofit每次创建RestAdapter和自定义的接口对象是很耗费资源的，因此不需要每次去创建，要使用单例模式。确实Retrofit是通过添加运行时注解，采用动态代理的方式去创建实例的。","text":"单例模式很适合Android开发，对于Retrofit(Android开发中一个非常优秀的Rest Client)，也要使用单例模式获取实例。 下面是Jake大神在stackoverflow上关于Retrofit的使用问题的回答。 Both the RestAdapter and the generated instance of your services (MyTaskService in this case) are extremely expensive objects and should be used as singletons. This means that you should only ever call restAdapter.create once and re-use the same instance of MyTaskService every time you need to interact with. I cannot stress this enough. You can use the regular singleton pattern in order to ensure that there only is ever a single instance of these objects that you use everywhere. A dependency injection framework would also be something that could be used to manage these instances but would be a bit overkill if you are not already utilizing it. 从中我们可以看到 Jake表示 Retrofit每次创建RestAdapter和自定义的接口对象是很耗费资源的，因此不需要每次去创建，要使用单例模式。确实Retrofit是通过添加运行时注解，采用动态代理的方式去创建实例的。线程安全的饿汉式： 1234567891011121314151617181920private static GitHubApi sGitHubApi = new GitHubApi(); private GitHub sGitHub;private GitHubApi() &#123; initService();&#125;public GitHub getGitHub() &#123; return sGitHub;&#125;public static GitHubApi getInstance() &#123; return sGitHubApi;&#125;private void initService() &#123; RestAdapter sRestAdapter = new RestAdapter.Builder().setClient(getOkClient()).setEndpoint(BASE_URL).build(); sGitHub = sRestAdapter.create(GitHub.class);&#125; or 懒汉式： 123456789private static GitHub sGitHub;public static GitHub getGitHub() &#123; if (null == sGitHub) &#123; RestAdapter sRestAdapter = new RestAdapter.Builder().setClient(getOkClient()).setEndpoint(BASE_URL).build(); sGitHub = sRestAdapter.create(GitHub.class); &#125; return sGitHub;&#125;","categories":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.luffyjet.com/techblog/tags/Retrofit/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://www.luffyjet.com/techblog/categories/android/"}]},{"title":"基于Hexo框架的静态博客搭建","slug":"to_build_hexo_blog","date":"2014-12-21T14:20:20.000Z","updated":"2016-02-22T07:48:18.000Z","comments":true,"path":"2014/12/21/to_build_hexo_blog/","link":"","permalink":"http://www.luffyjet.com/techblog/techblog/2014/12/21/to_build_hexo_blog/","excerpt":"BBS,WordPress都折腾过，弄来弄去最后发现GitHub上可以搭建自定义域名的静态页面博客，所以摸索了一下如何在github上搭建自己的博客。开始按着GitHub pages的介绍和文档，搭建了基于Jekyll的博客，但是折腾了很久都没发现自己喜欢的博客模板。后来搜索，发现了Hexo框架，顿时觉得这正是我所需要的。到后面发现了国内的GitCafe,把博客部署到GitCafe上，访问速度快了很多。 Hexo框架的安装也没有Jekyll繁琐，对Windows的支持比Jekyll好很多。Jekyll在windows下各种问题。 Hexo的安装","text":"BBS,WordPress都折腾过，弄来弄去最后发现GitHub上可以搭建自定义域名的静态页面博客，所以摸索了一下如何在github上搭建自己的博客。开始按着GitHub pages的介绍和文档，搭建了基于Jekyll的博客，但是折腾了很久都没发现自己喜欢的博客模板。后来搜索，发现了Hexo框架，顿时觉得这正是我所需要的。到后面发现了国内的GitCafe,把博客部署到GitCafe上，访问速度快了很多。 Hexo框架的安装也没有Jekyll繁琐，对Windows的支持比Jekyll好很多。Jekyll在windows下各种问题。 Hexo的安装 保证你系统安装好了NodeJS 和 Git客户端后，安装部署Hexo到本机只需要按照Hexo官网的说明输入几行命令即可。 Windows下安装NodeJS就是动动鼠标的事，Linux下相对麻烦些。我尝试了将Hexo安装在Ubantu上。记录下我的安装过程。 Ubantu下安装NodeJS 不要sudo apt-get xxx 的方式安装NodeJS，这样只会安装过时的版本，到时候无法安装Hexo，以防万一先执行下卸载命令: $sudo apt-get autoremove npm $sudo apt-get autoremove nodejs 首先去官网下载Linux对应的NodeJS源码包 Ubantu下直接双击打开拖出来就是。 确保NodeJS能正常编译还要检查Python、gcc、g++ $ sudo apt-get install python $ sudo apt-get install build-essential $ sudo apt-get install gcc $ sudo apt-get install g++ 然后cd 进入到你解压的目录 执行 ./configuremakesudo make install Make的过程有点久，请耐心等待。以上步骤完毕之后，进行软链接: $ sudo ln -s /usr/local/bin/node /usr/bin/node $ sudo ln -s /usr/local/bin/npm /usr/bin/npm 然后再查看NodeJS版本,没有执行上面命令时会出现无法找到node的错误 $ node -v $ npm -v 到此NodeJS安装完毕。 Ubantu下安装Git安装Hexo下载主题、插件和部署到github，都用的Git 。 所以你还得安装Git，Windows下载安装文件安装即可记得安装的时候勾选添加到环境变量。Ubantu下执行 sudo apt-get install git 完成Git安装后按照一开始说的命令进行Hexo安装。安装好之后就是查看Hexo的文档和插件,还有主题页面，去完善自己的静态博客了。 选择一套自己喜欢的主题，按照说明进行切换，然后添加评论，搜索等等插件。然后执行 hexo server 用浏览器打开 localhost:4000 ，查看运行效果。 那么要怎么部署到服务端上呢，接着看下面。 怎么在Github上创建自己的博客，参考 https://pages.github.com/ https://help.github.com/categories/github-pages-basics/ 怎么在GitCafe上创建自己的博客，参考 GitCafe的帮助页面 https://gitcafe.com/GitCafe/Help GitCafe是国内的类Github网站，也支持搭建博客，访问速度会比Github快。上面的帮助页面包含SSH Key配置(当然你也可以选择Https方式提交),如何部署博客到GitCafe Pages服务，如何绑定自定义域名等。 新版的Hexo部署博客的方式有所改变 统一了Git方式的部署，需要安装插件具体查看官方文档： http://hexo.io/docs/deployment.html 绑定自定义域名到Github Pages在自己的域名解析设置页面内添加一条A记录到以下IP的其中一个即可 192.30.252.153 192.30.252.154 然后在相应的Github项目内创建一个CNAME文件，中间只记录你的域名 比如 www.luffyjet.com DNS设置具体过程请参考 http://jingyan.baidu.com/article/dca1fa6fa1e403f1a5405262.html 用Markdown写文章Hexo博客的文章都是用Markdown写作的，具体语法参考 标准版: http://daringfireball.net/projects/markdown/syntax Github版: https://help.github.com/articles/github-flavored-markdown/ 更多的Hexo使用和修改请仔细阅读官方文档。更多的个性化设置介绍请参考下面的文章： http://zipperary.com/categories/hexo/","categories":[{"name":"other","slug":"other","permalink":"http://www.luffyjet.com/techblog/categories/other/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.luffyjet.com/techblog/tags/hexo/"}],"keywords":[{"name":"other","slug":"other","permalink":"http://www.luffyjet.com/techblog/categories/other/"}]}]}